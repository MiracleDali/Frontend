<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>let命令</title>

    <style>
        h1 {
            color: rgb(207, 157, 20);
        }
        img {
            width: 50%;
            border: 1px solid rgb(207, 157, 20);
        }
    </style>

</head>
<body>
    <h1>let 命令</h1>
    <span>
        ES6 引入了 let 命令，用来声明变量。
        let 声明的变量，只在 let 命令所在的代码块内有效。
        let 声明的变量，必须先声明后使用
    </span>
    <ul>
        <li>var关键字：函数级别的作用域</li>
        <li>-------</li>
        <li>let关键字：块级作用域 可以理解为只在花括号{}内生效
            <br>
            <img src="1.png" alt="">
        </li>
        <li>
            let关键字：不会变量提升
        </li>
        <li>
            let关键字：不能重复声明
            <br>
            <img src="2.png" alt=""></img>
        </li>
    </ul>



    <script>

        // var 的作域是函数级别
        if(true){
            var a = 1;
        }
        console.log(a);
        // 因为var 是函数级别，所以b是函数作用域的变量 在函数外面调用 var 定义的变量 会报错
        // 下面注释掉的这个调用会报错
        /*
        function fn(){
            var b = 2;
        }
        fn();
        console.log(b);
        */


        // let 的作域是块级作用域
        if(true){
            let c = 3;
            console.log(c);
        }
        // let 作域是块级作用域，是块级作用域的变量 在函数外面调用 let 块级作用域的变量 会报错
        // 下面注释掉的这个调用会报错
        /*
        if(true){
            let d = 4;
        }
        console.log(d);
        */

        console.log('因为let 作域是块级作用域，所以可以在多个循环中重复使用同一个变量名他们不会冲突')
        for(let i=10; i<15; i++){
            console.log(i);
        }
        for(let i=20; i<25; i++){
            console.log(i);
        }


        console.log('-------------')
        // 因为 var 声明的变量 i 具有函数作用域，在循环结束后 i 的值为 10，而数组 e 中的函数形成了闭包，保存了对同一个变量 i 的引用，所以当 e[6]() 执行时输出的是 10。
        var e = [];
        for (var i = 0; i < 10; i++) {
            e[i] = function () {
                console.log(i);
            }
        }
        // console.log(e);
        e[6]();  // 10


        // let版本: 每个函数捕获各自循环时的 i 值（块级作用域），输出对应的索引值 6
        let f = [];
        for (let i = 0; i < 10; i++) {
            f[i] = function () {
                console.log(i);
            }
        }
        // console.log(f);
        f[6]();
       

        console.log(aa)  // 变量提升（Hoisting）现象  输出 undefined，而不会报错
        var aa = 10;

        // let 声明的变量不会像 var 那样被提升到作用域顶部 暂时性死区: 从作用域开始到 let 声明完成之前，访问变量 bb 会进入"暂时性死区"
        console.log(bb)  
        let bb = 10;



        

    </script>
    

</body>
</html>